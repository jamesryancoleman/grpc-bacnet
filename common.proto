syntax = "proto3";
package bos;

// option sysmod_package = "github.com/jamesryancoleman/bos/services/sysmod";
// option go_package = "github.com/jamesryancoleman/bos/services/device";

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";
// import "google/protobuf/empty.proto";

message Empty{} 

// Headers are used to track from what service or app a request is made and 
// from which service a response is returned.
message Header {
    string Src = 1;
    string Dst = 2;

    uint64 TxnId = 3;
    string SessionToken = 4;
    
    google.protobuf.Timestamp Time = 5;
    
    optional string app = 6; // field for app to self-attest its name
    optional string user = 7;
}

// GetPairs are returned by services when get requests are made
message GetPair {
    string Key = 1;
    string Value = 2;
    optional Dtype Dtype = 3;
    optional google.protobuf.Timestamp time = 4;

    optional GetError Error = 5; // is this the right error type?
    optional string ErrorMsg = 6;
}

// SetPairs are returned by services when set requests are made
message SetPair {
    // used in requests
    string Key = 1;
    string Value = 2;

    // used in responses
    optional Dtype Dtype = 3;
    
    bool Ok = 4;

    optional SetError Error = 5; // is this the right error type?
    optional string ErrorMsg = 6;
}

message GetRequest {
    Header Header = 1; 
    repeated string Keys = 2;
}

message GetResponse {
    optional Header Header = 1;
    repeated GetPair Pairs = 2;

    optional ServiceError Error = 3;
    optional string ErrorMsg = 4;
}

message SetRequest {
    optional Header Header = 1;
    repeated SetPair Pairs = 2;
}

message SetResponse {
    optional Header Header = 1;
    repeated SetPair Pairs = 2;

    optional ServiceError Error = 3;
    optional string ErrorMsg = 4;
}

enum ServiceError {
    SERVICE_ERROR_NONE = 0;
    SERVICE_ERROR_UNSPECIFIED = 1;
    SERVICE_ERROR_NO_RESPONSE = 2;
    SERVICE_ERROR_TIMEOUT = 3;

    SERVICE_ERROR_ACCESS_DENIED = 7;
}

enum GetError {
    GET_ERROR_NONE = 0;
    GET_ERROR_UNSPECIFIED = 1;
    GET_ERROR_KEY_DOES_NOT_EXIST = 2;
    GET_ERROR_TIMEOUT = 3;
    GET_ERROR_COULD_NOT_RESOLVE_DRIVER = 4;
    GET_ERROR_COULD_NOT_RESOLVE_ADDR = 5;
    GET_ERROR_COULD_NOT_RESOLVE_XREF = 6;
    GET_ERROR_ACCESS_DENIED = 7;
}
           
// the DeviceControl service provides the fundamental driver functionality for
// Setting and Getting values from devices independent of the underlying protocol.
service DeviceControl {
    // get a value from a driver
    rpc Get(GetRequest) returns (GetResponse);
    
    // set a value on a driver
    rpc Set(SetRequest) returns (SetResponse);
}

enum SetError {
    SET_ERROR_NONE = 0;
    SET_ERROR_UNSPECIFIED = 1;
    SET_ERROR_KEY_DOES_NOT_EXIST = 2;
    SET_ERROR_TIMEOUT = 3;
    SET_ERROR_COULD_NOT_RESOLVE_DRIVER = 4;
    SET_ERROR_COULD_NOT_RESOLVE_ADDR = 5;
    SET_ERROR_COULD_NOT_RESOLVE_XREF = 6;
    SET_ERROR_ACCESS_DENIED = 7;
    SET_ERROR_READ_ONLY = 8;
    SET_ERROR_INVALID_VALUE_TYPE = 9;
}

message BasicQueryRequest {
    optional Header Header = 1;

    string Query = 2;
}

message BasicQueryResponse {
    optional Header Header = 1;
    optional string Query = 2; // should this be optional?

    repeated Triple Results = 3;    

    optional QueryError Error = 4;
    optional string ErrorMsg = 5;
}

// the sysmod service
message DeviceQueryRequest {
    optional Header Header = 1;

    // TODO: support arbitrary queries returning devices
    optional string Query = 2;

    repeated string Names = 3;
    repeated string Types = 4;
    repeated string Locations = 5;

    repeated string ChildTypes = 6;
}

message PointQueryRequest {
    optional Header Header = 1;

    optional string Query = 2;

    optional string Device = 3; // "5", "dev:5", "bos://localhost/bos/dev/5"
    repeated string Names = 4;
    repeated string Types = 5;
    repeated string Locations = 6;
    optional bool ConsiderDeviceLoc = 7; 
    optional Dtype Resource = 8; // 30, 40 or 48

    repeated string ParentTypes = 9;

    optional QueryError Error = 11;
    optional string ErrorMsg = 12;
}

message QueryResponse {
    optional Header Header = 1;
    optional string Query = 2; // should this be optional?
    repeated string Values = 3;
    optional Dtype Dtype = 4;
    optional QueryError Error = 5;
    optional string ErrorMsg = 6;
}

// in general at least 1 field must be used
message Triple {
    optional string Subject = 1;
    optional string Predicate = 2;
    optional string Object = 3;
}

message MakeDeviceRequest {
    string Name = 1;
    
    repeated string Types = 2; 
    repeated string Locations = 3;
    
    optional string Driver = 4;

    repeated Triple OtherProperties = 10;
}

message MakePointRequest {
    string Device = 1;
    string Name = 2;
    
    repeated string Types = 3;
    repeated string Locations = 4;

    optional string Xref = 5;

    repeated Triple OtherProperties = 10;
}

message MakeDriverRequest {
    string Name = 1;
    string Host = 2;
    string Port = 3;
    string Image = 4;
    string Container = 5;
}

message MakeResponse {
    string Url = 1;
    optional string ErrorMsg = 2;
}

message DeleteRequest {
    optional Header Header = 1;

    optional string Query = 2;
    
    optional Triple Triple = 3;
}

message DeleteResponse {
    repeated string Urls = 1;
}

// the PointId (pid) service takes classes, names, or regexes
service Sysmod {
    // sysmod querying rpcs
    rpc QueryDevices(DeviceQueryRequest) returns (QueryResponse);
    rpc QueryPoints(PointQueryRequest) returns (QueryResponse);

    rpc BasicQuery(BasicQueryRequest) returns (BasicQueryResponse);

    // rpc NameToPoint(GetRequest) returns (QueryResponse);
    rpc GetName(GetRequest) returns (QueryResponse);
    rpc GetDriver(GetRequest) returns(QueryResponse);
    rpc GetDriverXref(GetRequest) returns(QueryResponse);

    // sysmod populating rpcs
    rpc MakeDevice(MakeDeviceRequest) returns (MakeResponse);
    rpc MakePoint(MakePointRequest) returns (MakeResponse);
    rpc MakeDriver(MakeDriverRequest) returns (MakeResponse);

    rpc Delete(DeleteRequest) returns (DeleteResponse);
}

enum QueryError {
    QUERY_ERROR_NONE = 0;
    QUERY_ERROR_UNSPECIFIED = 1;
    // GET_ERROR_KEY_DOES_NOT_EXIST = 2;
    QUERY_ERROR_TIMEOUT = 3;
    QUERY_ERROR_UNKNOWN_PREFIX = 4;
    QUERY_ERROR_ACCESS_DENIED = 5;
}                
                
// Values are returned as strings. Dtype is used to decode to data types.
enum Dtype {
    UNSPECIFIED = 0;
    
    NULL = 1;

    DOUBLE = 10; // float64
    FLOAT = 11;  // float32
    INT32 = 12;  // int32
    INT64 = 13;  // int64
    UINT32 = 14;
    UINT64 = 15;
    SINT32 = 16;
    SINT64 = 17;
    FIXED32 = 18;
    FIXED64 = 19;
    SFIXED32 = 20;
    SFIXED64 = 21;
    BOOL = 22;
    STRING = 23;
    BYTES = 24;

    // sysmod response types
    POINT = 30; // e.g., "bos://localhost/bos/dev/5/pts/1"
    POINT_LIST = 31; // e.g., "bos://localhost/bos/dev/5/pts/1 bos://localhost/bos/dev/6/pts/1"

    DEVICE = 40;
    DEVICE_LIST = 41;

    DRIVER = 48;
    DRIVER_XREF = 49;
}

service HealthCheck {
    rpc Ping(Empty) returns (Empty);
}

message HistoryRequest {
    string Start = 1;
    string End = 2;
    repeated string Keys = 3;
    optional int32 Limit = 4;
}

message HisRow {
    string Timestamp = 1;
    float Value = 2;
    string Id = 3;
}

message HistoryResponse {
    Header Header = 1;
    repeated HisRow Rows = 2;
    ServiceError Error = 3;
}

message RefreshRatesRequest {}
message RefreshRatesResponse {
    ServiceError Error = 1;
    string ErrorMsg = 2;
}

service History {
    // returns rows of history from the historian
    rpc GetHistory(HistoryRequest) returns (HistoryResponse);
    // set the sample rate of a given point
    rpc GetSampleRate(SetRequest) returns (SetResponse);
    // set the sample rate of a given point
    rpc SetSampleRate(SetRequest) returns (SetResponse);
    // remotely trigger an update of the rates used by the historian.
    // this may be removed in future updates and its functionality triggered
    // by SetSampleRate.
    rpc RefreshRates(RefreshRatesRequest) returns(RefreshRatesResponse);
}

service Forecast {
    // returns 
    rpc Get(GetForecastRequest) returns (GetForecastResponse);

    rpc Set(SetForecastRequest) returns (SetForecastResponse);
}

message SetForecastRequest {
    Header header = 1;
    ForecastEntry forecast = 2;
}

message SetForecastResponse {
    Header header = 1;
    string id = 2; // a uuid assigned by the server
}

message GetForecastRequest {
    Header header = 1;
    string forecast_id = 2;
    string point_uri = 3;

    google.protobuf.Timestamp start = 4;
    google.protobuf.Timestamp end = 5;    

    // TODO: think of example of forecast selection criteria. Starting with latest
    // other examples: nearest to timestamp, previous_N, highest_confidence 
}

message GetForecastResponse {
    Header header = 1;
    repeated ForecastEntry forecasts = 2;
}

message ForecastEntry {
    // if not provided defaults to server time
    optional string forecast_id = 1; // only for responses
    optional google.protobuf.Timestamp created_at = 2; 
    string point_uri = 3;
    optional string forecast_type = 4; // could be uri
    string model = 5;
    string model_version = 6;
    optional google.protobuf.Struct metadata = 7;
    repeated ForecastValue values = 8;
}

message ForecastValue {
    string forecast_id = 1;
    google.protobuf.Timestamp created_at = 2;
    google.protobuf.Timestamp target_time = 3;
    string scenario = 4;
    double value = 5;
}


message RunRequest {
    optional Header Header = 1;
    string Image = 3;
    optional string Container = 4;
    repeated string Args = 5;
    map <string, string> Kwargs = 6;
    map <string, string> EnvVars = 7;
    int64 Timeout = 8; // none < 0; default == 0 ; seconds > 0
}

message RunResponse {
    Header Header = 1;
    uint64 txn = 2;
    string container_id = 3;
    int32 ExitCode = 4;
    optional string StdOut = 5;
    optional string ErrorMsg= 6;

    repeated string ReturnValues = 7; // may be none
}

// message RegisterIntervalRequest {
//     Header Header = 1;
//     uint32 Interval = 2; // run every <Interval> seconds
//     repeated RunRequest Requests = 3; // an ordered list of RunRequests
//     optional bool RunNow = 4;
// }

// // the scheduler will create the containers but not necessarily start them
// message RegisterIntervalReponse {
//     Header Header = 1;
//     uint32 IntervalId = 2;
//     repeated string ContainerIds = 3; // 12 character truncated docker ids
// }

// 
message CronRequest {
    Header Header = 1;
    string CronStr = 2;
    repeated RunRequest Requests = 3;
    bool OnStart = 4;
}

message CronResponse {
    Header header = 1;
    bool ok = 2;
    string uuid = 3;
}

message RegisterHandlerRequest {
    Header Header = 1;
    string Event = 2; // a particular topic
    repeated RunRequest Requests = 3;
}

message RegisterHandlerResponse {
    Header Header = 1;
    bool Ok = 2;
}

message EventHandlersRequest {
    Header header = 1;
}

message EventHandlersResponse {
    Header header = 1;

}

message UnregisterHandlerRequest {
    Header Header = 1;
    string Event = 2; // a particular topic
    repeated RunRequest Requests = 3;
}

message UnregisterHandlerResponse {
    Header Header = 1;
    bool Ok = 2;
}

message RunningJobsRequest {
    Header Header = 1;
    repeated uint64 Txns = 2; // optional
}

message RunningJobsResponse {
    Header Header = 1;
    repeated JobData jobs = 2;
}

enum AppStatus {
    STATUS_UNKNOWN = 0;
    STATUS_STOPPED = 1;
    STATUS_STOPPING = 2;
    STATUS_SCHEDULED = 3;
    STATUS_RUNNING = 4;
}

message JobData {
    string name = 1;
    uint64 txn = 2;
    string id = 3; // to track the container
    string user = 4;
    string run_on = 5;
    google.protobuf.Timestamp created = 6;
    google.protobuf.Timestamp next = 7;
    google.protobuf.Timestamp previous = 8;
    AppStatus status = 9;
    
}

message StopRequest {
    Header header = 1;
    repeated uint64 txns = 2; 
    repeated string ids = 3; // the container id
}

message StopResponse {
    Header header = 1;
}


message CronTableResponse {
    Header header = 1;
    repeated JobData jobs = 2;
}

message UnregisterCronRequest {
    Header header = 1;
    string uuid = 2; // the cron uuid
}

message UnregisterCronResponse {
    Header header = 1;
    bool ok = 2;
}

message LibraryRequest {
    Header header = 1;
}

message LibraryResponse {
    Header header = 1;
    repeated AppDesciption apps = 2;
}

message AppDesciption {
    string image = 1;
    string description = 2;
    string usage = 3;
    // google.protobuf.Timestamp last_update = 2;

}

service Scheduler {
    rpc Get(GetRequest) returns(GetResponse);
    rpc Set(SetRequest) returns(SetResponse);

    rpc Library(LibraryRequest) returns(LibraryResponse);

    // run an image 1 time
    rpc Run(RunRequest) returns(RunResponse);
    rpc RunningJobs(RunningJobsRequest) returns(RunningJobsResponse);
    rpc Stop(StopRequest) returns(StopResponse);

    // scheule an rpc to run periodicially
    // rpc RegisterInterval(RegisterIntervalRequest) returns(RegisterIntervalReponse);

    // schedule a cron job
    rpc RegisterCron(CronRequest) returns(CronResponse);
    rpc CronTable(RunningJobsRequest) returns(RunningJobsResponse);
    rpc UnregisterCron(UnregisterCronRequest) returns(UnregisterCronResponse);

    // bind the container that will be called when an event occurs
    rpc RegisterHandler(RegisterHandlerRequest) returns(RegisterHandlerResponse);
    rpc EventHandlers(EventHandlersRequest) returns(EventHandlersResponse);
    rpc UnregisterHandler(UnregisterHandlerRequest) returns(UnregisterHandlerResponse);
}

// service Events {
//     // the SetRequests are TOPIC: MSG
//     rpc Publish(PublishRequest) returns(PublishResponse);
//     rpc Subscribe(SubscribeRequest) returns (stream Event);
// }


service EventBus {
  rpc Publish(PublishRequest) returns (PublishResponse);
  rpc Subscribe(SubscribeRequest) returns (stream Event);
  rpc Replay(ReplayRequest) returns (stream Event);
}


message Event {
  string id                          = 1;  // UUID, assigned by the gateway
  string topic                       = 2;  // e.g. "alarms", "setpoints", "telemetry"
  string source                      = 3;  // container/app that produced it
  string type                        = 4;  // event classification, e.g. "alarm.high_zone_temp"
  google.protobuf.Timestamp timestamp = 5;
  bytes payload                      = 6;  // actual data — opaque to the bus
  string payload_content_type        = 7;  // "application/json", "application/protobuf", etc.
  map<string, string> metadata       = 8;  // freeform k/v for routing, filtering, tracing
  int64 offset                       = 9;  // Kafka offset, populated on delivery not publish
}


message PublishRequest {
  string topic                       = 1;
  string type                        = 2;
  bytes payload                      = 3;
  string payload_content_type        = 4;
  map<string, string> metadata       = 5;
  string partition_key               = 6;  // controls Kafka partitioning — e.g. device ID
                                           // ensures ordering per-device
}

message PublishResponse {
  string event_id                    = 1;  // the UUID the gateway assigned
  int64 offset                       = 2;  // Kafka offset for confirmation
  google.protobuf.Timestamp accepted_at = 3;
}

message SubscribeRequest {
  repeated string topics             = 1;  // subscribe to multiple topics at once
  string consumer_id                 = 2;  // maps to Kafka consumer group
  repeated Filter filters            = 3;  // optional server-side filtering
  StartPosition start                = 4;  // where to begin consuming
}

message Filter {
  string field                       = 1;  // "type", "source", or a metadata key
  string pattern                     = 2;  // exact match or glob, e.g. "alarm.*"
}

enum StartPosition {
  LATEST = 0;                              // new events only (default)
  EARLIEST = 1;                            // from beginning of retention
  AT_TIMESTAMP = 2;                        // use replay_from_timestamp
  AT_OFFSET = 3;                           // use replay_from_offset
}

message ReplayRequest {
  string topic                       = 1;  // single topic for replay
  oneof start_from {
    google.protobuf.Timestamp from_timestamp = 2;
    int64 from_offset                = 3;
    string from_event_id             = 4;  // gateway resolves to offset
  }
  google.protobuf.Timestamp until    = 5;  // optional end bound, omit for open-ended
  repeated Filter filters            = 6;
}